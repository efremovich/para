#fuel-app 
# Разработка
Нужно взять за основу down stream gateway. Реализовать там: 
- подключение к базе
- подключение к rabbitmq
- реализовать хранилище minio
- logger
- swagger
- rpc/rest
## Авторизация
Я создам для вас полный пример реализации JWT авторизации на Go с регистрацией, логином и логаутом.

## Структура проекта

```
project/
├── main.go
├── handlers/
│   └── auth.go
├── models/
│   └── user.go
├── middleware/
│   └── auth.go
├── database/
│   └── database.go
└── go.mod
```

## 1. go.mod

```go
module jwt-auth-app

go 1.21

require (
    github.com/golang-jwt/jwt/v5 v5.0.0
    github.com/gorilla/mux v1.8.0
    golang.org/x/crypto v0.14.0
)
```

## 2. models/user.go

```go
package models

import (
    "golang.org/x/crypto/bcrypt"
    "time"
)

type User struct {
    ID        string    `json:"id"`
    Email     string    `json:"email"`
    Password  string    `json:"-"`
    CreatedAt time.Time `json:"created_at"`
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type RegisterRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type AuthResponse struct {
    Token string `json:"token"`
    User  *User  `json:"user"`
}

// HashPassword хеширует пароль
func (u *User) HashPassword() error {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.Password = string(hashedPassword)
    return nil
}

// CheckPassword проверяет пароль
func (u *User) CheckPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
    return err == nil
}
```

## 3. database/database.go

```go
package database

import (
    "jwt-auth-app/models"
    "sync"
)

// InMemoryDB - простая in-memory база данных для демонстрации
type InMemoryDB struct {
    users map[string]*models.User
    mu    sync.RWMutex
}

var DB = &InMemoryDB{
    users: make(map[string]*models.User),
}

func (db *InMemoryDB) CreateUser(user *models.User) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    if _, exists := db.users[user.Email]; exists {
        return ErrUserExists
    }
    
    db.users[user.Email] = user
    return nil
}

func (db *InMemoryDB) GetUserByEmail(email string) (*models.User, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    user, exists := db.users[email]
    if !exists {
        return nil, ErrUserNotFound
    }
    
    return user, nil
}

func (db *InMemoryDB) UserExists(email string) bool {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    _, exists := db.users[email]
    return exists
}

// Ошибки базы данных
var (
    ErrUserExists   = &DBError{Message: "user already exists"}
    ErrUserNotFound = &DBError{Message: "user not found"}
)

type DBError struct {
    Message string
}

func (e *DBError) Error() string {
    return e.Message
}
```

## 4. middleware/auth.go

```go
package middleware

import (
    "context"
    "jwt-auth-app/models"
    "net/http"
    "strings"

    "github.com/golang-jwt/jwt/v5"
)

type contextKey string

const (
    UserContextKey contextKey = "user"
    JWTSecret                 = "your-secret-key-change-in-production"
)

// JWTMiddleware проверяет JWT токен
func JWTMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }

        // Формат: Bearer <token>
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
            return
        }

        tokenString := parts[1]
        claims := &jwt.MapClaims{}

        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
            return []byte(JWTSecret), nil
        })

        if err != nil || !token.Valid {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        // Извлекаем email из claims
        email, ok := (*claims)["email"].(string)
        if !ok {
            http.Error(w, "Invalid token claims", http.StatusUnauthorized)
            return
        }

        // Создаем user object и добавляем в контекст
        user := &models.User{
            Email: email,
        }

        ctx := context.WithValue(r.Context(), UserContextKey, user)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// GenerateToken создает JWT токен
func GenerateToken(user *models.User) (string, error) {
    claims := jwt.MapClaims{
        "email": user.Email,
        "exp":   jwt.NewNumericDate(jwt.NewNumericDate(time.Now()).Add(24 * time.Hour)),
        "iat":   jwt.NewNumericDate(time.Now()),
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(JWTSecret))
}
```

## 5. handlers/auth.go

```go
package handlers

import (
    "encoding/json"
    "jwt-auth-app/database"
    "jwt-auth-app/middleware"
    "jwt-auth-app/models"
    "net/http"
    "time"

    "github.com/google/uuid"
)

// RegisterHandler обработчик регистрации
func RegisterHandler(w http.ResponseWriter, r *http.Request) {
    var req models.RegisterRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    // Валидация
    if req.Email == "" || req.Password == "" {
        http.Error(w, "Email and password are required", http.StatusBadRequest)
        return
    }

    if len(req.Password) < 6 {
        http.Error(w, "Password must be at least 6 characters", http.StatusBadRequest)
        return
    }

    // Создаем пользователя
    user := &models.User{
        ID:        uuid.New().String(),
        Email:     req.Email,
        Password:  req.Password,
        CreatedAt: time.Now(),
    }

    // Хешируем пароль
    if err := user.HashPassword(); err != nil {
        http.Error(w, "Error creating user", http.StatusInternalServerError)
        return
    }

    // Сохраняем в базу
    if err := database.DB.CreateUser(user); err != nil {
        http.Error(w, err.Error(), http.StatusConflict)
        return
    }

    // Генерируем токен
    token, err := middleware.GenerateToken(user)
    if err != nil {
        http.Error(w, "Error generating token", http.StatusInternalServerError)
        return
    }

    response := models.AuthResponse{
        Token: token,
        User:  user,
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(response)
}

// LoginHandler обработчик входа
func LoginHandler(w http.ResponseWriter, r *http.Request) {
    var req models.LoginRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    // Получаем пользователя из базы
    user, err := database.DB.GetUserByEmail(req.Email)
    if err != nil {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }

    // Проверяем пароль
    if !user.CheckPassword(req.Password) {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }

    // Генерируем токен
    token, err := middleware.GenerateToken(user)
    if err != nil {
        http.Error(w, "Error generating token", http.StatusInternalServerError)
        return
    }

    response := models.AuthResponse{
        Token: token,
        User:  user,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// LogoutHandler обработчик выхода
func LogoutHandler(w http.ResponseWriter, r *http.Request) {
    // В JWT логаут обычно делается на клиенте путем удаления токена
    // На сервере можно добавить токен в blacklist, но для простоты просто возвращаем успех
    
    response := map[string]string{
        "message": "Successfully logged out",
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// ProfileHandler возвращает информацию о пользователе
func ProfileHandler(w http.ResponseWriter, r *http.Request) {
    user, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
    if !ok {
        http.Error(w, "User not found in context", http.StatusUnauthorized)
        return
    }

    // Не возвращаем пароль
    userResponse := &models.User{
        ID:        user.ID,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(userResponse)
}
```

## 6. main.go

```go
package main

import (
    "jwt-auth-app/handlers"
    "jwt-auth-app/middleware"
    "log"
    "net/http"

    "github.com/gorilla/mux"
)

func main() {
    r := mux.NewRouter()

    // Публичные маршруты
    r.HandleFunc("/register", handlers.RegisterHandler).Methods("POST")
    r.HandleFunc("/login", handlers.LoginHandler).Methods("POST")
    r.HandleFunc("/logout", handlers.LogoutHandler).Methods("POST")

    // Защищенные маршруты
    protected := r.PathPrefix("/api").Subrouter()
    protected.Use(middleware.JWTMiddleware)
    protected.HandleFunc("/profile", handlers.ProfileHandler).Methods("GET")

    // Health check
    r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"status": "ok"}`))
    }).Methods("GET")

    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

## Примеры использования

### Регистрация
```bash
curl -X POST http://localhost:8080/register \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'
```

### Логин
```bash
curl -X POST http://localhost:8080/login \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'
```

### Получение профиля
```bash
curl -X GET http://localhost:8080/api/profile \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

### Логаут
```bash
curl -X POST http://localhost:8080/logout \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

## Важные замечания

1. **Безопасность**: В продакшене используйте надежный секретный ключ и храните его в безопасном месте
2. **База данных**: В примере используется in-memory база, замените на реальную (PostgreSQL, MySQL и т.д.)
3. **Пароли**: Используется bcrypt для хеширования паролей
4. **Токены**: JWT токены имеют срок жизни 24 часа
5. **Валидация**: Добавьте более строгую валидацию email и паролей

Этот пример предоставляет базовую функциональность JWT авторизации, которую можно расширить в зависимости от ваших потребностей.



