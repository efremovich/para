Я создам для вас полную схему действий (action schema) для авторизации с автоматическим обновлением токена при истечении.

1. Обновленная структура проекта

```
project/
├── main.go
├── handlers/
│   └── auth.go
├── models/
│   └── user.go
├── middleware/
│   └── auth.go
├── database/
│   └── database.go
├── services/
│   └── auth.go
└── client/
    └── auth_client.go
```

2. Обновленные модели (models/user.go)

```go
package models

import (
    "golang.org/x/crypto/bcrypt"
    "time"
)

type User struct {
    ID        string    `json:"id"`
    Email     string    `json:"email"`
    Password  string    `json:"-"`
    CreatedAt time.Time `json:"created_at"`
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type RegisterRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type AuthResponse struct {
    Token        string `json:"token"`
    RefreshToken string `json:"refresh_token"`
    User         *User  `json:"user"`
}

type RefreshTokenRequest struct {
    RefreshToken string `json:"refresh_token"`
}

type TokenPair struct {
    Token        string `json:"token"`
    RefreshToken string `json:"refresh_token"`
}

// HashPassword хеширует пароль
func (u *User) HashPassword() error {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.Password = string(hashedPassword)
    return nil
}

// CheckPassword проверяет пароль
func (u *User) CheckPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
    return err == nil
}
```

3. Обновленная база данных (database/database.go)

```go
package database

import (
    "jwt-auth-app/models"
    "sync"
    "time"
)

// RefreshToken хранит информацию о refresh токене
type RefreshToken struct {
    Token     string    `json:"token"`
    UserID    string    `json:"user_id"`
    ExpiresAt time.Time `json:"expires_at"`
    CreatedAt time.Time `json:"created_at"`
}

// InMemoryDB - простая in-memory база данных
type InMemoryDB struct {
    users         map[string]*models.User
    refreshTokens map[string]*RefreshToken
    mu            sync.RWMutex
}

var DB = &InMemoryDB{
    users:         make(map[string]*models.User),
    refreshTokens: make(map[string]*RefreshToken),
}

func (db *InMemoryDB) CreateUser(user *models.User) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    if _, exists := db.users[user.Email]; exists {
        return ErrUserExists
    }
    
    db.users[user.Email] = user
    return nil
}

func (db *InMemoryDB) GetUserByEmail(email string) (*models.User, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    user, exists := db.users[email]
    if !exists {
        return nil, ErrUserNotFound
    }
    
    return user, nil
}

func (db *InMemoryDB) GetUserByID(id string) (*models.User, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    for _, user := range db.users {
        if user.ID == id {
            return user, nil
        }
    }
    
    return nil, ErrUserNotFound
}

func (db *InMemoryDB) UserExists(email string) bool {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    _, exists := db.users[email]
    return exists
}

// Refresh Token methods
func (db *InMemoryDB) SaveRefreshToken(token *RefreshToken) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    db.refreshTokens[token.Token] = token
    return nil
}

func (db *InMemoryDB) GetRefreshToken(token string) (*RefreshToken, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    refreshToken, exists := db.refreshTokens[token]
    if !exists {
        return nil, ErrTokenNotFound
    }
    
    if time.Now().After(refreshToken.ExpiresAt) {
        return nil, ErrTokenExpired
    }
    
    return refreshToken, nil
}

func (db *InMemoryDB) DeleteRefreshToken(token string) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    delete(db.refreshTokens, token)
    return nil
}

func (db *InMemoryDB) DeleteUserRefreshTokens(userID string) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    for token, refreshToken := range db.refreshTokens {
        if refreshToken.UserID == userID {
            delete(db.refreshTokens, token)
        }
    }
    
    return nil
}

// Ошибки базы данных
var (
    ErrUserExists   = &DBError{Message: "user already exists"}
    ErrUserNotFound = &DBError{Message: "user not found"}
    ErrTokenNotFound = &DBError{Message: "refresh token not found"}
    ErrTokenExpired  = &DBError{Message: "refresh token expired"}
)

type DBError struct {
    Message string
}

func (e *DBError) Error() string {
    return e.Message
}
```

4. Обновленный middleware (middleware/auth.go)

```go
package middleware

import (
    "context"
    "jwt-auth-app/database"
    "jwt-auth-app/models"
    "net/http"
    "strings"
    "time"

    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"
)

type contextKey string

const (
    UserContextKey contextKey = "user"
    JWTSecret                 = "your-secret-key-change-in-production"
    RefreshTokenSecret        = "your-refresh-secret-key-change-in-production"
    AccessTokenDuration       = 15 * time.Minute    // 15 минут
    RefreshTokenDuration      = 7 * 24 * time.Hour  // 7 дней
)

// JWTMiddleware проверяет JWT токен
func JWTMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }

        // Формат: Bearer <token>
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
            return
        }

        tokenString := parts[1]
        claims := &jwt.MapClaims{}

        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
            return []byte(JWTSecret), nil
        })

        if err != nil {
            if err == jwt.ErrTokenExpired {
                // Токен истек - можно вернуть специальный код для обновления
                w.Header().Set("X-Token-Expired", "true")
                http.Error(w, "Token expired", http.StatusUnauthorized)
                return
            }
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        if !token.Valid {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        // Извлекаем email из claims
        email, ok := (*claims)["email"].(string)
        if !ok {
            http.Error(w, "Invalid token claims", http.StatusUnauthorized)
            return
        }

        // Получаем пользователя из базы
        user, err := database.DB.GetUserByEmail(email)
        if err != nil {
            http.Error(w, "User not found", http.StatusUnauthorized)
            return
        }

        // Создаем user object и добавляем в контекст
        ctx := context.WithValue(r.Context(), UserContextKey, user)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// GenerateTokenPair создает пару access и refresh токенов
func GenerateTokenPair(user *models.User) (*models.TokenPair, error) {
    // Access Token
    accessTokenClaims := jwt.MapClaims{
        "email": user.Email,
        "sub":   user.ID,
        "exp":   time.Now().Add(AccessTokenDuration).Unix(),
        "iat":   time.Now().Unix(),
        "type":  "access",
    }

    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessTokenClaims)
    accessTokenString, err := accessToken.SignedString([]byte(JWTSecret))
    if err != nil {
        return nil, err
    }

    // Refresh Token
    refreshTokenID := uuid.New().String()
    refreshTokenClaims := jwt.MapClaims{
        "sub": user.ID,
        "jti": refreshTokenID,
        "exp": time.Now().Add(RefreshTokenDuration).Unix(),
        "iat": time.Now().Unix(),
        "type": "refresh",
    }

    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshTokenClaims)
    refreshTokenString, err := refreshToken.SignedString([]byte(RefreshTokenSecret))
    if err != nil {
        return nil, err
    }

    // Сохраняем refresh token в базу
    refreshTokenData := &database.RefreshToken{
        Token:     refreshTokenID,
        UserID:    user.ID,
        ExpiresAt: time.Now().Add(RefreshTokenDuration),
        CreatedAt: time.Now(),
    }

    if err := database.DB.SaveRefreshToken(refreshTokenData); err != nil {
        return nil, err
    }

    return &models.TokenPair{
        Token:        accessTokenString,
        RefreshToken: refreshTokenString,
    }, nil
}

// ValidateRefreshToken проверяет refresh token
func ValidateRefreshToken(tokenString string) (*jwt.Token, jwt.MapClaims, error) {
    claims := jwt.MapClaims{}
    token, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {
        return []byte(RefreshTokenSecret), nil
    })

    if err != nil {
        return nil, nil, err
    }

    if !token.Valid {
        return nil, nil, jwt.ErrTokenInvalidClaims
    }

    // Проверяем тип токена
    if claims["type"] != "refresh" {
        return nil, nil, jwt.ErrTokenInvalidClaims
    }

    // Проверяем наличие в базе
    tokenID, ok := claims["jti"].(string)
    if !ok {
        return nil, nil, jwt.ErrTokenInvalidClaims
    }

    _, err = database.DB.GetRefreshToken(tokenID)
    if err != nil {
        return nil, nil, err
    }

    return token, claims, nil
}
```

5. Сервис авторизации (services/auth.go)

```go
package services

import (
    "jwt-auth-app/database"
    "jwt-auth-app/middleware"
    "jwt-auth-app/models"
    "net/http"
)

// AuthService управляет процессами авторизации
type AuthService struct {
    db *database.InMemoryDB
}

func NewAuthService() *AuthService {
    return &AuthService{
        db: database.DB,
    }
}

// Login выполняет вход пользователя
func (s *AuthService) Login(email, password string) (*models.AuthResponse, error) {
    user, err := s.db.GetUserByEmail(email)
    if err != nil {
        return nil, err
    }

    if !user.CheckPassword(password) {
        return nil, &AuthError{Message: "invalid credentials", Code: http.StatusUnauthorized}
    }

    tokenPair, err := middleware.GenerateTokenPair(user)
    if err != nil {
        return nil, err
    }

    return &models.AuthResponse{
        Token:        tokenPair.Token,
        RefreshToken: tokenPair.RefreshToken,
        User:         user,
    }, nil
}

// Register регистрирует нового пользователя
func (s *AuthService) Register(email, password string) (*models.AuthResponse, error) {
    if s.db.UserExists(email) {
        return nil, &AuthError{Message: "user already exists", Code: http.StatusConflict}
    }

    user := &models.User{
        ID:       generateUserID(),
        Email:    email,
        Password: password,
    }

    if err := user.HashPassword(); err != nil {
        return nil, err
    }

    if err := s.db.CreateUser(user); err != nil {
        return nil, err
    }

    tokenPair, err := middleware.GenerateTokenPair(user)
    if err != nil {
        return nil, err
    }

    return &models.AuthResponse{
        Token:        tokenPair.Token,
        RefreshToken: tokenPair.RefreshToken,
        User:         user,
    }, nil
}

// RefreshTokens обновляет пару токенов
func (s *AuthService) RefreshTokens(refreshToken string) (*models.TokenPair, error) {
    token, claims, err := middleware.ValidateRefreshToken(refreshToken)
    if err != nil || !token.Valid {
        return nil, &AuthError{Message: "invalid refresh token", Code: http.StatusUnauthorized}
    }

    userID, ok := claims["sub"].(string)
    if !ok {
        return nil, &AuthError{Message: "invalid token claims", Code: http.StatusUnauthorized}
    }

    user, err := s.db.GetUserByID(userID)
    if err != nil {
        return nil, &AuthError{Message: "user not found", Code: http.StatusUnauthorized}
    }

    // Удаляем использованный refresh token
    tokenID, _ := claims["jti"].(string)
    s.db.DeleteRefreshToken(tokenID)

    // Генерируем новую пару токенов
    return middleware.GenerateTokenPair(user)
}

// Logout выполняет выход пользователя
func (s *AuthService) Logout(userID string) error {
    return s.db.DeleteUserRefreshTokens(userID)
}

// AuthError представляет ошибку авторизации
type AuthError struct {
    Message string
    Code    int
}

func (e *AuthError) Error() string {
    return e.Message
}

func generateUserID() string {
    return uuid.New().String()
}
```

6. Клиент для работы с авторизацией (client/auth_client.go)

```go
package client

import (
    "bytes"
    "encoding/json"
    "jwt-auth-app/models"
    "net/http"
    "sync"
    "time"
)

// AuthClient клиент для работы с API авторизации
type AuthClient struct {
    baseURL      string
    token        string
    refreshToken string
    mu           sync.RWMutex
    httpClient   *http.Client
    onTokenRefresh func(newToken, newRefreshToken string)
}

type ClientConfig struct {
    BaseURL       string
    HTTPClient    *http.Client
    OnTokenRefresh func(newToken, newRefreshToken string)
}

func NewAuthClient(config ClientConfig) *AuthClient {
    if config.HTTPClient == nil {
        config.HTTPClient = &http.Client{Timeout: 30 * time.Second}
    }

    return &AuthClient{
        baseURL:      config.BaseURL,
        httpClient:   config.HTTPClient,
        onTokenRefresh: config.OnTokenRefresh,
    }
}

// SetTokens устанавливает токены
func (c *AuthClient) SetTokens(token, refreshToken string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.token = token
    c.refreshToken = refreshToken
}

// GetTokens возвращает текущие токены
func (c *AuthClient) GetTokens() (string, string) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.token, c.refreshToken
}

// Login выполняет вход
func (c *AuthClient) Login(email, password string) error {
    loginReq := models.LoginRequest{
        Email:    email,
        Password: password,
    }

    resp, err := c.doRequest("POST", "/login", loginReq, false)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var authResp models.AuthResponse
    if err := json.NewDecoder(resp.Body).Decode(&authResp); err != nil {
        return err
    }

    c.SetTokens(authResp.Token, authResp.RefreshToken)
    return nil
}

// Register выполняет регистрацию
func (c *AuthClient) Register(email, password string) error {
    registerReq := models.RegisterRequest{
        Email:    email,
        Password: password,
    }

    resp, err := c.doRequest("POST", "/register", registerReq, false)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var authResp models.AuthResponse
    if err := json.NewDecoder(resp.Body).Decode(&authResp); err != nil {
        return err
    }

    c.SetTokens(authResp.Token, authResp.RefreshToken)
    return nil
}

// RefreshTokens обновляет токены
func (c *AuthClient) RefreshTokens() error {
    _, refreshToken := c.GetTokens()
    if refreshToken == "" {
        return &ClientError{Message: "no refresh token available"}
    }

    refreshReq := models.RefreshTokenRequest{
        RefreshToken: refreshToken,
    }

    resp, err := c.doRequest("POST", "/refresh", refreshReq, false)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var tokenPair models.TokenPair
    if err := json.NewDecoder(resp.Body).Decode(&tokenPair); err != nil {
        return err
    }

    c.SetTokens(tokenPair.Token, tokenPair.RefreshToken)
    
    if c.onTokenRefresh != nil {
        c.onTokenRefresh(tokenPair.Token, tokenPair.RefreshToken)
    }

    return nil
}

// DoRequest выполняет запрос с автоматическим обновлением токена при истечении
func (c *AuthClient) DoRequest(method, path string, body interface{}) (*http.Response, error) {
    return c.doRequest(method, path, body, true)
}

// doRequest внутренний метод для выполнения запросов
func (c *AuthClient) doRequest(method, path string, body interface{}, withRetry bool) (*http.Response, error) {
    token, _ := c.GetTokens()

    var jsonBody []byte
    if body != nil {
        var err error
        jsonBody, err = json.Marshal(body)
        if err != nil {
            return nil, err
        }
    }

    req, err := http.NewRequest(method, c.baseURL+path, bytes.NewBuffer(jsonBody))
    if err != nil {
        return nil, err
    }

    req.Header.Set("Content-Type", "application/json")
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }

    // Если токен истек и включен retry - пытаемся обновить
    if withRetry && resp.StatusCode == http.StatusUnauthorized && 
       resp.Header.Get("X-Token-Expired") == "true" {
        resp.Body.Close()
        
        // Обновляем токены
        if err := c.RefreshTokens(); err != nil {
            return nil, err
        }
        
        // Повторяем запрос с новым токеном
        return c.doRequest(method, path, body, false) // false чтобы избежать бесконечного цикла
    }

    return resp, nil
}

// Logout выполняет выход
func (c *AuthClient) Logout() error {
    resp, err := c.doRequest("POST", "/logout", nil, true)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    c.SetTokens("", "")
    return nil
}

// ClientError представляет ошибку клиента
type ClientError struct {
    Message string
}

func (e *ClientError) Error() string {
    return e.Message
}
```

7. Обновленные обработчики (handlers/auth.go)

```go
package handlers

import (
    "encoding/json"
    "jwt-auth-app/models"
    "jwt-auth-app/services"
    "net/http"
)

type AuthHandler struct {
    authService *services.AuthService
}

func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// RegisterHandler обработчик регистрации
func (h *AuthHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) {
    var req models.RegisterRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    // Валидация
    if req.Email == "" || req.Password == "" {
        http.Error(w, "Email and password are required", http.StatusBadRequest)
        return
    }

    if len(req.Password) < 6 {
        http.Error(w, "Password must be at least 6 characters", http.StatusBadRequest)
        return
    }

    authResp, err := h.authService.Register(req.Email, req.Password)
    if err != nil {
        if authErr, ok := err.(*services.AuthError); ok {
            http.Error(w, authErr.Message, authErr.Code)
            return
        }
        http.Error(w, "Error creating user", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(authResp)
}

// LoginHandler обработчик входа
func (h *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {
    var req models.LoginRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    authResp, err := h.authService.Login(req.Email, req.Password)
    if err != nil {
        if authErr, ok := err.(*services.AuthError); ok {
            http.Error(w, authErr.Message, authErr.Code)
            return
        }
        http.Error(w, "Error during login", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(authResp)
}

// Ref

Я создам для вас полную схему действий (action schema) для авторизации с автоматическим обновлением токена при истечении.

1. Обновленная структура проекта

```
project/
├── main.go
├── handlers/
│   └── auth.go
├── models/
│   └── user.go
├── middleware/
│   └── auth.go
├── database/
│   └── database.go
├── services/
│   └── auth.go
└── client/
    └── auth_client.go
```

2. Обновленные модели (models/user.go)

```go
package models

import (
    "golang.org/x/crypto/bcrypt"
    "time"
)

type User struct {
    ID        string    `json:"id"`
    Email     string    `json:"email"`
    Password  string    `json:"-"`
    CreatedAt time.Time `json:"created_at"`
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type RegisterRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type AuthResponse struct {
    Token        string `json:"token"`
    RefreshToken string `json:"refresh_token"`
    User         *User  `json:"user"`
}

type RefreshTokenRequest struct {
    RefreshToken string `json:"refresh_token"`
}

type TokenPair struct {
    Token        string `json:"token"`
    RefreshToken string `json:"refresh_token"`
}

// HashPassword хеширует пароль
func (u *User) HashPassword() error {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.Password = string(hashedPassword)
    return nil
}

// CheckPassword проверяет пароль
func (u *User) CheckPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
    return err == nil
}
```

3. Обновленная база данных (database/database.go)

```go
package database

import (
    "jwt-auth-app/models"
    "sync"
    "time"
)

// RefreshToken хранит информацию о refresh токене
type RefreshToken struct {
    Token     string    `json:"token"`
    UserID    string    `json:"user_id"`
    ExpiresAt time.Time `json:"expires_at"`
    CreatedAt time.Time `json:"created_at"`
}

// InMemoryDB - простая in-memory база данных
type InMemoryDB struct {
    users         map[string]*models.User
    refreshTokens map[string]*RefreshToken
    mu            sync.RWMutex
}

var DB = &InMemoryDB{
    users:         make(map[string]*models.User),
    refreshTokens: make(map[string]*RefreshToken),
}

func (db *InMemoryDB) CreateUser(user *models.User) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    if _, exists := db.users[user.Email]; exists {
        return ErrUserExists
    }
    
    db.users[user.Email] = user
    return nil
}

func (db *InMemoryDB) GetUserByEmail(email string) (*models.User, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    user, exists := db.users[email]
    if !exists {
        return nil, ErrUserNotFound
    }
    
    return user, nil
}

func (db *InMemoryDB) GetUserByID(id string) (*models.User, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    for _, user := range db.users {
        if user.ID == id {
            return user, nil
        }
    }
    
    return nil, ErrUserNotFound
}

func (db *InMemoryDB) UserExists(email string) bool {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    _, exists := db.users[email]
    return exists
}

// Refresh Token methods
func (db *InMemoryDB) SaveRefreshToken(token *RefreshToken) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    db.refreshTokens[token.Token] = token
    return nil
}

func (db *InMemoryDB) GetRefreshToken(token string) (*RefreshToken, error) {
    db.mu.RLock()
    defer db.mu.RUnlock()
    
    refreshToken, exists := db.refreshTokens[token]
    if !exists {
        return nil, ErrTokenNotFound
    }
    
    if time.Now().After(refreshToken.ExpiresAt) {
        return nil, ErrTokenExpired
    }
    
    return refreshToken, nil
}

func (db *InMemoryDB) DeleteRefreshToken(token string) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    delete(db.refreshTokens, token)
    return nil
}

func (db *InMemoryDB) DeleteUserRefreshTokens(userID string) error {
    db.mu.Lock()
    defer db.mu.Unlock()
    
    for token, refreshToken := range db.refreshTokens {
        if refreshToken.UserID == userID {
            delete(db.refreshTokens, token)
        }
    }
    
    return nil
}

// Ошибки базы данных
var (
    ErrUserExists   = &DBError{Message: "user already exists"}
    ErrUserNotFound = &DBError{Message: "user not found"}
    ErrTokenNotFound = &DBError{Message: "refresh token not found"}
    ErrTokenExpired  = &DBError{Message: "refresh token expired"}
)

type DBError struct {
    Message string
}

func (e *DBError) Error() string {
    return e.Message
}
```

4. Обновленный middleware (middleware/auth.go)

```go
package middleware

import (
    "context"
    "jwt-auth-app/database"
    "jwt-auth-app/models"
    "net/http"
    "strings"
    "time"

    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"
)

type contextKey string

const (
    UserContextKey contextKey = "user"
    JWTSecret                 = "your-secret-key-change-in-production"
    RefreshTokenSecret        = "your-refresh-secret-key-change-in-production"
    AccessTokenDuration       = 15 * time.Minute    // 15 минут
    RefreshTokenDuration      = 7 * 24 * time.Hour  // 7 дней
)

// JWTMiddleware проверяет JWT токен
func JWTMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }

        // Формат: Bearer <token>
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
            return
        }

        tokenString := parts[1]
        claims := &jwt.MapClaims{}

        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
            return []byte(JWTSecret), nil
        })

        if err != nil {
            if err == jwt.ErrTokenExpired {
                // Токен истек - можно вернуть специальный код для обновления
                w.Header().Set("X-Token-Expired", "true")
                http.Error(w, "Token expired", http.StatusUnauthorized)
                return
            }
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        if !token.Valid {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        // Извлекаем email из claims
        email, ok := (*claims)["email"].(string)
        if !ok {
            http.Error(w, "Invalid token claims", http.StatusUnauthorized)
            return
        }

        // Получаем пользователя из базы
        user, err := database.DB.GetUserByEmail(email)
        if err != nil {
            http.Error(w, "User not found", http.StatusUnauthorized)
            return
        }

        // Создаем user object и добавляем в контекст
        ctx := context.WithValue(r.Context(), UserContextKey, user)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// GenerateTokenPair создает пару access и refresh токенов
func GenerateTokenPair(user *models.User) (*models.TokenPair, error) {
    // Access Token
    accessTokenClaims := jwt.MapClaims{
        "email": user.Email,
        "sub":   user.ID,
        "exp":   time.Now().Add(AccessTokenDuration).Unix(),
        "iat":   time.Now().Unix(),
        "type":  "access",
    }

    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessTokenClaims)
    accessTokenString, err := accessToken.SignedString([]byte(JWTSecret))
    if err != nil {
        return nil, err
    }

    // Refresh Token
    refreshTokenID := uuid.New().String()
    refreshTokenClaims := jwt.MapClaims{
        "sub": user.ID,
        "jti": refreshTokenID,
        "exp": time.Now().Add(RefreshTokenDuration).Unix(),
        "iat": time.Now().Unix(),
        "type": "refresh",
    }

    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshTokenClaims)
    refreshTokenString, err := refreshToken.SignedString([]byte(RefreshTokenSecret))
    if err != nil {
        return nil, err
    }

    // Сохраняем refresh token в базу
    refreshTokenData := &database.RefreshToken{
        Token:     refreshTokenID,
        UserID:    user.ID,
        ExpiresAt: time.Now().Add(RefreshTokenDuration),
        CreatedAt: time.Now(),
    }

    if err := database.DB.SaveRefreshToken(refreshTokenData); err != nil {
        return nil, err
    }

    return &models.TokenPair{
        Token:        accessTokenString,
        RefreshToken: refreshTokenString,
    }, nil
}

// ValidateRefreshToken проверяет refresh token
func ValidateRefreshToken(tokenString string) (*jwt.Token, jwt.MapClaims, error) {
    claims := jwt.MapClaims{}
    token, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {
        return []byte(RefreshTokenSecret), nil
    })

    if err != nil {
        return nil, nil, err
    }

    if !token.Valid {
        return nil, nil, jwt.ErrTokenInvalidClaims
    }

    // Проверяем тип токена
    if claims["type"] != "refresh" {
        return nil, nil, jwt.ErrTokenInvalidClaims
    }

    // Проверяем наличие в базе
    tokenID, ok := claims["jti"].(string)
    if !ok {
        return nil, nil, jwt.ErrTokenInvalidClaims
    }

    _, err = database.DB.GetRefreshToken(tokenID)
    if err != nil {
        return nil, nil, err
    }

    return token, claims, nil
}
```

5. Сервис авторизации (services/auth.go)

```go
package services

import (
    "jwt-auth-app/database"
    "jwt-auth-app/middleware"
    "jwt-auth-app/models"
    "net/http"
)

// AuthService управляет процессами авторизации
type AuthService struct {
    db *database.InMemoryDB
}

func NewAuthService() *AuthService {
    return &AuthService{
        db: database.DB,
    }
}

// Login выполняет вход пользователя
func (s *AuthService) Login(email, password string) (*models.AuthResponse, error) {
    user, err := s.db.GetUserByEmail(email)
    if err != nil {
        return nil, err
    }

    if !user.CheckPassword(password) {
        return nil, &AuthError{Message: "invalid credentials", Code: http.StatusUnauthorized}
    }

    tokenPair, err := middleware.GenerateTokenPair(user)
    if err != nil {
        return nil, err
    }

    return &models.AuthResponse{
        Token:        tokenPair.Token,
        RefreshToken: tokenPair.RefreshToken,
        User:         user,
    }, nil
}

// Register регистрирует нового пользователя
func (s *AuthService) Register(email, password string) (*models.AuthResponse, error) {
    if s.db.UserExists(email) {
        return nil, &AuthError{Message: "user already exists", Code: http.StatusConflict}
    }

    user := &models.User{
        ID:       generateUserID(),
        Email:    email,
        Password: password,
    }

    if err := user.HashPassword(); err != nil {
        return nil, err
    }

    if err := s.db.CreateUser(user); err != nil {
        return nil, err
    }

    tokenPair, err := middleware.GenerateTokenPair(user)
    if err != nil {
        return nil, err
    }

    return &models.AuthResponse{
        Token:        tokenPair.Token,
        RefreshToken: tokenPair.RefreshToken,
        User:         user,
    }, nil
}

// RefreshTokens обновляет пару токенов
func (s *AuthService) RefreshTokens(refreshToken string) (*models.TokenPair, error) {
    token, claims, err := middleware.ValidateRefreshToken(refreshToken)
    if err != nil || !token.Valid {
        return nil, &AuthError{Message: "invalid refresh token", Code: http.StatusUnauthorized}
    }

    userID, ok := claims["sub"].(string)
    if !ok {
        return nil, &AuthError{Message: "invalid token claims", Code: http.StatusUnauthorized}
    }

    user, err := s.db.GetUserByID(userID)
    if err != nil {
        return nil, &AuthError{Message: "user not found", Code: http.StatusUnauthorized}
    }

    // Удаляем использованный refresh token
    tokenID, _ := claims["jti"].(string)
    s.db.DeleteRefreshToken(tokenID)

    // Генерируем новую пару токенов
    return middleware.GenerateTokenPair(user)
}

// Logout выполняет выход пользователя
func (s *AuthService) Logout(userID string) error {
    return s.db.DeleteUserRefreshTokens(userID)
}

// AuthError представляет ошибку авторизации
type AuthError struct {
    Message string
    Code    int
}

func (e *AuthError) Error() string {
    return e.Message
}

func generateUserID() string {
    return uuid.New().String()
}
```

6. Клиент для работы с авторизацией (client/auth_client.go)

```go
package client

import (
    "bytes"
    "encoding/json"
    "jwt-auth-app/models"
    "net/http"
    "sync"
    "time"
)

// AuthClient клиент для работы с API авторизации
type AuthClient struct {
    baseURL      string
    token        string
    refreshToken string
    mu           sync.RWMutex
    httpClient   *http.Client
    onTokenRefresh func(newToken, newRefreshToken string)
}

type ClientConfig struct {
    BaseURL       string
    HTTPClient    *http.Client
    OnTokenRefresh func(newToken, newRefreshToken string)
}

func NewAuthClient(config ClientConfig) *AuthClient {
    if config.HTTPClient == nil {
        config.HTTPClient = &http.Client{Timeout: 30 * time.Second}
    }

    return &AuthClient{
        baseURL:      config.BaseURL,
        httpClient:   config.HTTPClient,
        onTokenRefresh: config.OnTokenRefresh,
    }
}

// SetTokens устанавливает токены
func (c *AuthClient) SetTokens(token, refreshToken string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.token = token
    c.refreshToken = refreshToken
}

// GetTokens возвращает текущие токены
func (c *AuthClient) GetTokens() (string, string) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.token, c.refreshToken
}

// Login выполняет вход
func (c *AuthClient) Login(email, password string) error {
    loginReq := models.LoginRequest{
        Email:    email,
        Password: password,
    }

    resp, err := c.doRequest("POST", "/login", loginReq, false)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var authResp models.AuthResponse
    if err := json.NewDecoder(resp.Body).Decode(&authResp); err != nil {
        return err
    }

    c.SetTokens(authResp.Token, authResp.RefreshToken)
    return nil
}

// Register выполняет регистрацию
func (c *AuthClient) Register(email, password string) error {
    registerReq := models.RegisterRequest{
        Email:    email,
        Password: password,
    }

    resp, err := c.doRequest("POST", "/register", registerReq, false)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var authResp models.AuthResponse
    if err := json.NewDecoder(resp.Body).Decode(&authResp); err != nil {
        return err
    }

    c.SetTokens(authResp.Token, authResp.RefreshToken)
    return nil
}

// RefreshTokens обновляет токены
func (c *AuthClient) RefreshTokens() error {
    _, refreshToken := c.GetTokens()
    if refreshToken == "" {
        return &ClientError{Message: "no refresh token available"}
    }

    refreshReq := models.RefreshTokenRequest{
        RefreshToken: refreshToken,
    }

    resp, err := c.doRequest("POST", "/refresh", refreshReq, false)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var tokenPair models.TokenPair
    if err := json.NewDecoder(resp.Body).Decode(&tokenPair); err != nil {
        return err
    }

    c.SetTokens(tokenPair.Token, tokenPair.RefreshToken)
    
    if c.onTokenRefresh != nil {
        c.onTokenRefresh(tokenPair.Token, tokenPair.RefreshToken)
    }

    return nil
}

// DoRequest выполняет запрос с автоматическим обновлением токена при истечении
func (c *AuthClient) DoRequest(method, path string, body interface{}) (*http.Response, error) {
    return c.doRequest(method, path, body, true)
}

// doRequest внутренний метод для выполнения запросов
func (c *AuthClient) doRequest(method, path string, body interface{}, withRetry bool) (*http.Response, error) {
    token, _ := c.GetTokens()

    var jsonBody []byte
    if body != nil {
        var err error
        jsonBody, err = json.Marshal(body)
        if err != nil {
            return nil, err
        }
    }

    req, err := http.NewRequest(method, c.baseURL+path, bytes.NewBuffer(jsonBody))
    if err != nil {
        return nil, err
    }

    req.Header.Set("Content-Type", "application/json")
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }

    // Если токен истек и включен retry - пытаемся обновить
    if withRetry && resp.StatusCode == http.StatusUnauthorized && 
       resp.Header.Get("X-Token-Expired") == "true" {
        resp.Body.Close()
        
        // Обновляем токены
        if err := c.RefreshTokens(); err != nil {
            return nil, err
        }
        
        // Повторяем запрос с новым токеном
        return c.doRequest(method, path, body, false) // false чтобы избежать бесконечного цикла
    }

    return resp, nil
}

// Logout выполняет выход
func (c *AuthClient) Logout() error {
    resp, err := c.doRequest("POST", "/logout", nil, true)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    c.SetTokens("", "")
    return nil
}

// ClientError представляет ошибку клиента
type ClientError struct {
    Message string
}

func (e *ClientError) Error() string {
    return e.Message
}
```

7. Обновленные обработчики (handlers/auth.go)

```go
package handlers

import (
    "encoding/json"
    "jwt-auth-app/models"
    "jwt-auth-app/services"
    "net/http"
)

type AuthHandler struct {
    authService *services.AuthService
}

func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// RegisterHandler обработчик регистрации
func (h *AuthHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) {
    var req models.RegisterRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    // Валидация
    if req.Email == "" || req.Password == "" {
        http.Error(w, "Email and password are required", http.StatusBadRequest)
        return
    }

    if len(req.Password) < 6 {
        http.Error(w, "Password must be at least 6 characters", http.StatusBadRequest)
        return
    }

    authResp, err := h.authService.Register(req.Email, req.Password)
    if err != nil {
        if authErr, ok := err.(*services.AuthError); ok {
            http.Error(w, authErr.Message, authErr.Code)
            return
        }
        http.Error(w, "Error creating user", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(authResp)
}

// LoginHandler обработчик входа
func (h *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {
    var req models.LoginRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    authResp, err := h.authService.Login(req.Email, req.Password)
    if err != nil {
        if authErr, ok := err.(*services.AuthError); ok {
            http.Error(w, authErr.Message, authErr.Code)
            return
        }
        http.Error(w, "Error during login", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(authResp)
}

// RefreshHandler обработчик обновления токенов
func (h *AuthHandler) RefreshHandler(w http.ResponseWriter, r *http.Request) {
    var req models.RefreshTokenRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    tokenPair, err := h.authService.RefreshTokens(req.RefreshToken)
    if err != nil {
        if authErr, ok := err.(*services.AuthError); ok {
            http.Error(w, authErr.Message, authErr.Code)
            return
        }
        http.Error(w, "Error refreshing tokens", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(tokenPair)
}

// LogoutHandler обработчик выхода
func (h *AuthHandler) LogoutHandler(w http.ResponseWriter, r *http.Request) {
    user, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
    if !ok {
        http.Error(w, "User not found in context", http.StatusUnauthorized)
        return
    }

    if err := h.authService.Logout(user.ID); err != nil {
        http.Error(w, "Error during logout", http.StatusInternalServerError)
        return
    }

    response := map[string]string{
        "message": "Successfully logged out",
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// ProfileHandler возвращает информацию о пользователе
func (h *AuthHandler) ProfileHandler(w http.ResponseWriter, r *http.Request) {
    user, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
    if !ok {
        http.Error(w, "User not found in context", http.StatusUnauthorized)
        return
    }

    // Не возвращаем пароль
    userResponse := &models.User{
        ID:        user.ID,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(userResponse)
}
```

8. Обновленный main.go

```go
package main

import (
    "jwt-auth-app/handlers"
    "jwt-auth-app/middleware"
    "log"
    "net/http"

    "github.com/gorilla/mux"
)

func main() {
    r := mux.NewRouter()
    authHandler := handlers.NewAuthHandler()

    // Публичные маршруты
    r.HandleFunc("/register", authHandler.RegisterHandler).Methods("POST")
    r.HandleFunc("/login", authHandler.LoginHandler).Methods("POST")
    r.HandleFunc("/refresh", authHandler.RefreshHandler).Methods("POST")
    r.HandleFunc("/logout", authHandler.LogoutHandler).Methods("POST")

    // Защищенные маршруты
    protected := r.PathPrefix("/api").Subrouter()
    protected.Use(middleware.JWTMiddleware)
    protected.HandleFunc("/profile", authHandler.ProfileHandler).Methods("GET")

    // Health check
    r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"status": "ok"}`))
    }).Methods("GET")

    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

Пример использования клиента

```go
package main

import (
    "jwt-auth-app/client"
    "log"
)

func main() {
    // Создаем клиент
    authClient := client.NewAuthClient(client.ClientConfig{
        BaseURL: "http://localhost:8080",
        OnTokenRefresh: func(newToken, newRefreshToken string) {
            log.Println("Tokens refreshed successfully")
        },
    })

    // Регистрация
    err := authClient.Register("user@example.com", "password123")
    if err != nil {
        log.Fatal(err)
    }

    // Выполнение защищенного запроса
    resp, err := authClient.DoRequest("GET", "/api/profile", nil)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()

    log.Println("Request completed successfully")
}
```

Схема работы токенов

1. Access Token - короткоживущий (15 минут), для доступа к API
2. Refresh Token - долгоживущий (7 дней), для обновления access token
3. Автоматическое обновление - клиент автоматически обновляет токен при получении 401 ошибки
4. Безопасность - refresh tokens хранятся в базе и могут быть отозваны

Эта схема обеспечивает безопасную авторизацию с автоматическим обновлением токенов и защитой от несанкционированного доступа.